// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "manga.proto" (syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { SortOrder } from "./types";
import { SortField } from "./types";
import { Filter } from "./types";
/**
 * @generated from protobuf message MangaListRequest
 */
export interface MangaListRequest {
    /**
     * @generated from protobuf field: string User = 1
     */
    user: string;
    /**
     * @generated from protobuf field: string Tag = 2
     */
    tag: string;
    /**
     * @generated from protobuf field: mangaweb4.types.Filter Filter = 3
     */
    filter: Filter;
    /**
     * @generated from protobuf field: int32 Page = 4
     */
    page: number;
    /**
     * @generated from protobuf field: int32 ItemPerPage = 5
     */
    itemPerPage: number;
    /**
     * @generated from protobuf field: string Search = 6
     */
    search: string;
    /**
     * @generated from protobuf field: mangaweb4.types.SortField Sort = 7
     */
    sort: SortField;
    /**
     * @generated from protobuf field: mangaweb4.types.SortOrder Order = 8
     */
    order: SortOrder;
}
/**
 * @generated from protobuf message MangaListResponse
 */
export interface MangaListResponse {
    /**
     * @generated from protobuf field: bool TagFavorite = 1
     */
    tagFavorite: boolean;
    /**
     * @generated from protobuf field: int32 TotalPage = 2
     */
    totalPage: number;
    /**
     * @generated from protobuf field: repeated MangaListResponseItem Items = 3
     */
    items: MangaListResponseItem[];
}
/**
 * @generated from protobuf message MangaListResponseItem
 */
export interface MangaListResponseItem {
    /**
     * @generated from protobuf field: int32 ID = 1
     */
    iD: number;
    /**
     * @generated from protobuf field: string Name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: bool IsFavorite = 3
     */
    isFavorite: boolean;
    /**
     * @generated from protobuf field: bool IsRead = 4
     */
    isRead: boolean;
    /**
     * @generated from protobuf field: int32 PageCount = 5
     */
    pageCount: number;
    /**
     * @generated from protobuf field: bool HasFavoriteTag = 6
     */
    hasFavoriteTag: boolean;
    /**
     * @generated from protobuf field: int32 CurrentPage = 7
     */
    currentPage: number;
    /**
     * @generated from protobuf field: int32 MaxProgress = 8
     */
    maxProgress: number;
}
/**
 * @generated from protobuf message MangaThumbnailRequest
 */
export interface MangaThumbnailRequest {
    /**
     * @deprecated
     * @generated from protobuf field: string Name = 1 [deprecated = true]
     */
    name: string;
    /**
     * @generated from protobuf field: int32 ID = 2
     */
    iD: number;
}
/**
 * @generated from protobuf message MangaThumbnailResponse
 */
export interface MangaThumbnailResponse {
    /**
     * @generated from protobuf field: string ContentType = 1
     */
    contentType: string;
    /**
     * @generated from protobuf field: bytes Data = 2
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message MangaDetailRequest
 */
export interface MangaDetailRequest {
    /**
     * @generated from protobuf field: string User = 1
     */
    user: string;
    /**
     * @deprecated
     * @generated from protobuf field: string Name = 2 [deprecated = true]
     */
    name: string;
    /**
     * @generated from protobuf field: int32 ID = 3
     */
    iD: number;
}
/**
 * @generated from protobuf message MangaDetailResponse
 */
export interface MangaDetailResponse {
    /**
     * @generated from protobuf field: string Name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: bool Favorite = 2
     */
    favorite: boolean;
    /**
     * @generated from protobuf field: int32 PageCount = 3
     */
    pageCount: number;
    /**
     * @generated from protobuf field: int32 CurrentPage = 4
     */
    currentPage: number;
    /**
     * @generated from protobuf field: repeated MangaDetailResponseTagItem Tags = 5
     */
    tags: MangaDetailResponseTagItem[];
}
/**
 * @generated from protobuf message MangaDetailResponseTagItem
 */
export interface MangaDetailResponseTagItem {
    /**
     * @generated from protobuf field: int32 ID = 1
     */
    iD: number;
    /**
     * @generated from protobuf field: string Name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: bool IsFavorite = 3
     */
    isFavorite: boolean;
    /**
     * @generated from protobuf field: bool IsHidden = 4
     */
    isHidden: boolean;
}
/**
 * @generated from protobuf message MangaSetFavoriteRequest
 */
export interface MangaSetFavoriteRequest {
    /**
     * @generated from protobuf field: string User = 1
     */
    user: string;
    /**
     * @deprecated
     * @generated from protobuf field: string Name = 2 [deprecated = true]
     */
    name: string;
    /**
     * @generated from protobuf field: bool Favorite = 3
     */
    favorite: boolean;
    /**
     * @generated from protobuf field: int32 ID = 4
     */
    iD: number;
}
/**
 * @generated from protobuf message MangaSetFavoriteResponse
 */
export interface MangaSetFavoriteResponse {
    /**
     * @generated from protobuf field: string Name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: bool Favorite = 2
     */
    favorite: boolean;
}
/**
 * @generated from protobuf message MangaSetProgressRequest
 */
export interface MangaSetProgressRequest {
    /**
     * @generated from protobuf field: string User = 1
     */
    user: string;
    /**
     * @deprecated
     * @generated from protobuf field: string Name = 2 [deprecated = true]
     */
    name: string;
    /**
     * @generated from protobuf field: int32 Page = 3
     */
    page: number;
    /**
     * @generated from protobuf field: int32 ID = 4
     */
    iD: number;
}
/**
 * @generated from protobuf message MangaSetProgressResponse
 */
export interface MangaSetProgressResponse {
    /**
     * @generated from protobuf field: string User = 1
     */
    user: string;
    /**
     * @generated from protobuf field: string Name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: int32 Page = 3
     */
    page: number;
    /**
     * @generated from protobuf field: bool Succeed = 4
     */
    succeed: boolean;
}
/**
 * @generated from protobuf message MangaUpdateCoverRequest
 */
export interface MangaUpdateCoverRequest {
    /**
     * @generated from protobuf field: string Name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: int32 Index = 2
     */
    index: number;
    /**
     * @generated from protobuf field: int32 X = 3
     */
    x: number;
    /**
     * @generated from protobuf field: int32 Y = 4
     */
    y: number;
    /**
     * @generated from protobuf field: int32 Width = 5
     */
    width: number;
    /**
     * @generated from protobuf field: int32 Height = 6
     */
    height: number;
    /**
     * @deprecated
     * @generated from protobuf field: int32 ID = 7 [deprecated = true]
     */
    iD: number;
}
/**
 * @generated from protobuf message MangaUpdateCoverResponse
 */
export interface MangaUpdateCoverResponse {
    /**
     * @generated from protobuf field: bool Success = 1
     */
    success: boolean;
}
/**
 * @generated from protobuf message MangaPageImageRequest
 */
export interface MangaPageImageRequest {
    /**
     * @generated from protobuf field: string User = 1
     */
    user: string;
    /**
     * @deprecated
     * @generated from protobuf field: string Name = 2 [deprecated = true]
     */
    name: string;
    /**
     * @generated from protobuf field: int32 Index = 3
     */
    index: number;
    /**
     * @generated from protobuf field: int32 Width = 4
     */
    width: number;
    /**
     * @generated from protobuf field: int32 Height = 5
     */
    height: number;
    /**
     * @generated from protobuf field: int32 ID = 6
     */
    iD: number;
}
/**
 * @generated from protobuf message MangaPageImageResponse
 */
export interface MangaPageImageResponse {
    /**
     * @generated from protobuf field: string ContentType = 1
     */
    contentType: string;
    /**
     * @generated from protobuf field: bytes Data = 2
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message MangaPageImageStreamResponse
 */
export interface MangaPageImageStreamResponse {
    /**
     * @generated from protobuf field: string Filename = 1
     */
    filename: string;
    /**
     * @generated from protobuf field: string ContentType = 2
     */
    contentType: string;
    /**
     * @generated from protobuf field: bytes Data = 3
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: int32 Size = 4
     */
    size: number;
}
/**
 * @generated from protobuf message MangaRepairRequest
 */
export interface MangaRepairRequest {
    /**
     * @deprecated
     * @generated from protobuf field: string Name = 1 [deprecated = true]
     */
    name: string;
    /**
     * @generated from protobuf field: int32 ID = 3
     */
    iD: number;
}
/**
 * @generated from protobuf message MangaRepairResponse
 */
export interface MangaRepairResponse {
    /**
     * @generated from protobuf field: string Name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: bool IsSuccess = 2
     */
    isSuccess: boolean;
}
/**
 * @generated from protobuf message MangaDownloadRequest
 */
export interface MangaDownloadRequest {
    /**
     * @deprecated
     * @generated from protobuf field: string Name = 1 [deprecated = true]
     */
    name: string;
    /**
     * @generated from protobuf field: int32 ID = 2
     */
    iD: number;
}
/**
 * @generated from protobuf message MangaDownloadResponse
 */
export interface MangaDownloadResponse {
    /**
     * @generated from protobuf field: string Filename = 1
     */
    filename: string;
    /**
     * @generated from protobuf field: string ContentType = 2
     */
    contentType: string;
    /**
     * @generated from protobuf field: bytes Data = 3
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: int32 Size = 4
     */
    size: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class MangaListRequest$Type extends MessageType<MangaListRequest> {
    constructor() {
        super("MangaListRequest", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Tag", kind: "scalar", jsonName: "Tag", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Filter", kind: "enum", jsonName: "Filter", T: () => ["mangaweb4.types.Filter", Filter, "FILTER_"] },
            { no: 4, name: "Page", kind: "scalar", jsonName: "Page", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "ItemPerPage", kind: "scalar", jsonName: "ItemPerPage", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "Search", kind: "scalar", jsonName: "Search", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "Sort", kind: "enum", jsonName: "Sort", T: () => ["mangaweb4.types.SortField", SortField, "SORT_FIELD_"] },
            { no: 8, name: "Order", kind: "enum", jsonName: "Order", T: () => ["mangaweb4.types.SortOrder", SortOrder, "SORT_ORDER_"] }
        ]);
    }
    create(value?: PartialMessage<MangaListRequest>): MangaListRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.tag = "";
        message.filter = 0;
        message.page = 0;
        message.itemPerPage = 0;
        message.search = "";
        message.sort = 0;
        message.order = 0;
        if (value !== undefined)
            reflectionMergePartial<MangaListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaListRequest): MangaListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User */ 1:
                    message.user = reader.string();
                    break;
                case /* string Tag */ 2:
                    message.tag = reader.string();
                    break;
                case /* mangaweb4.types.Filter Filter */ 3:
                    message.filter = reader.int32();
                    break;
                case /* int32 Page */ 4:
                    message.page = reader.int32();
                    break;
                case /* int32 ItemPerPage */ 5:
                    message.itemPerPage = reader.int32();
                    break;
                case /* string Search */ 6:
                    message.search = reader.string();
                    break;
                case /* mangaweb4.types.SortField Sort */ 7:
                    message.sort = reader.int32();
                    break;
                case /* mangaweb4.types.SortOrder Order */ 8:
                    message.order = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string Tag = 2; */
        if (message.tag !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.tag);
        /* mangaweb4.types.Filter Filter = 3; */
        if (message.filter !== 0)
            writer.tag(3, WireType.Varint).int32(message.filter);
        /* int32 Page = 4; */
        if (message.page !== 0)
            writer.tag(4, WireType.Varint).int32(message.page);
        /* int32 ItemPerPage = 5; */
        if (message.itemPerPage !== 0)
            writer.tag(5, WireType.Varint).int32(message.itemPerPage);
        /* string Search = 6; */
        if (message.search !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.search);
        /* mangaweb4.types.SortField Sort = 7; */
        if (message.sort !== 0)
            writer.tag(7, WireType.Varint).int32(message.sort);
        /* mangaweb4.types.SortOrder Order = 8; */
        if (message.order !== 0)
            writer.tag(8, WireType.Varint).int32(message.order);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaListRequest
 */
export const MangaListRequest = new MangaListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaListResponse$Type extends MessageType<MangaListResponse> {
    constructor() {
        super("MangaListResponse", [
            { no: 1, name: "TagFavorite", kind: "scalar", jsonName: "TagFavorite", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "TotalPage", kind: "scalar", jsonName: "TotalPage", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "Items", kind: "message", jsonName: "Items", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MangaListResponseItem }
        ]);
    }
    create(value?: PartialMessage<MangaListResponse>): MangaListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tagFavorite = false;
        message.totalPage = 0;
        message.items = [];
        if (value !== undefined)
            reflectionMergePartial<MangaListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaListResponse): MangaListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool TagFavorite */ 1:
                    message.tagFavorite = reader.bool();
                    break;
                case /* int32 TotalPage */ 2:
                    message.totalPage = reader.int32();
                    break;
                case /* repeated MangaListResponseItem Items */ 3:
                    message.items.push(MangaListResponseItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool TagFavorite = 1; */
        if (message.tagFavorite !== false)
            writer.tag(1, WireType.Varint).bool(message.tagFavorite);
        /* int32 TotalPage = 2; */
        if (message.totalPage !== 0)
            writer.tag(2, WireType.Varint).int32(message.totalPage);
        /* repeated MangaListResponseItem Items = 3; */
        for (let i = 0; i < message.items.length; i++)
            MangaListResponseItem.internalBinaryWrite(message.items[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaListResponse
 */
export const MangaListResponse = new MangaListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaListResponseItem$Type extends MessageType<MangaListResponseItem> {
    constructor() {
        super("MangaListResponseItem", [
            { no: 1, name: "ID", kind: "scalar", jsonName: "ID", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "IsFavorite", kind: "scalar", jsonName: "IsFavorite", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "IsRead", kind: "scalar", jsonName: "IsRead", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "PageCount", kind: "scalar", jsonName: "PageCount", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "HasFavoriteTag", kind: "scalar", jsonName: "HasFavoriteTag", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "CurrentPage", kind: "scalar", jsonName: "CurrentPage", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "MaxProgress", kind: "scalar", jsonName: "MaxProgress", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MangaListResponseItem>): MangaListResponseItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iD = 0;
        message.name = "";
        message.isFavorite = false;
        message.isRead = false;
        message.pageCount = 0;
        message.hasFavoriteTag = false;
        message.currentPage = 0;
        message.maxProgress = 0;
        if (value !== undefined)
            reflectionMergePartial<MangaListResponseItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaListResponseItem): MangaListResponseItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 ID */ 1:
                    message.iD = reader.int32();
                    break;
                case /* string Name */ 2:
                    message.name = reader.string();
                    break;
                case /* bool IsFavorite */ 3:
                    message.isFavorite = reader.bool();
                    break;
                case /* bool IsRead */ 4:
                    message.isRead = reader.bool();
                    break;
                case /* int32 PageCount */ 5:
                    message.pageCount = reader.int32();
                    break;
                case /* bool HasFavoriteTag */ 6:
                    message.hasFavoriteTag = reader.bool();
                    break;
                case /* int32 CurrentPage */ 7:
                    message.currentPage = reader.int32();
                    break;
                case /* int32 MaxProgress */ 8:
                    message.maxProgress = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaListResponseItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 ID = 1; */
        if (message.iD !== 0)
            writer.tag(1, WireType.Varint).int32(message.iD);
        /* string Name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bool IsFavorite = 3; */
        if (message.isFavorite !== false)
            writer.tag(3, WireType.Varint).bool(message.isFavorite);
        /* bool IsRead = 4; */
        if (message.isRead !== false)
            writer.tag(4, WireType.Varint).bool(message.isRead);
        /* int32 PageCount = 5; */
        if (message.pageCount !== 0)
            writer.tag(5, WireType.Varint).int32(message.pageCount);
        /* bool HasFavoriteTag = 6; */
        if (message.hasFavoriteTag !== false)
            writer.tag(6, WireType.Varint).bool(message.hasFavoriteTag);
        /* int32 CurrentPage = 7; */
        if (message.currentPage !== 0)
            writer.tag(7, WireType.Varint).int32(message.currentPage);
        /* int32 MaxProgress = 8; */
        if (message.maxProgress !== 0)
            writer.tag(8, WireType.Varint).int32(message.maxProgress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaListResponseItem
 */
export const MangaListResponseItem = new MangaListResponseItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaThumbnailRequest$Type extends MessageType<MangaThumbnailRequest> {
    constructor() {
        super("MangaThumbnailRequest", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ID", kind: "scalar", jsonName: "ID", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MangaThumbnailRequest>): MangaThumbnailRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.iD = 0;
        if (value !== undefined)
            reflectionMergePartial<MangaThumbnailRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaThumbnailRequest): MangaThumbnailRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [deprecated = true] */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 ID */ 2:
                    message.iD = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaThumbnailRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [deprecated = true]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 ID = 2; */
        if (message.iD !== 0)
            writer.tag(2, WireType.Varint).int32(message.iD);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaThumbnailRequest
 */
export const MangaThumbnailRequest = new MangaThumbnailRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaThumbnailResponse$Type extends MessageType<MangaThumbnailResponse> {
    constructor() {
        super("MangaThumbnailResponse", [
            { no: 1, name: "ContentType", kind: "scalar", jsonName: "ContentType", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Data", kind: "scalar", jsonName: "Data", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MangaThumbnailResponse>): MangaThumbnailResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contentType = "";
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MangaThumbnailResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaThumbnailResponse): MangaThumbnailResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ContentType */ 1:
                    message.contentType = reader.string();
                    break;
                case /* bytes Data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaThumbnailResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ContentType = 1; */
        if (message.contentType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contentType);
        /* bytes Data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaThumbnailResponse
 */
export const MangaThumbnailResponse = new MangaThumbnailResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaDetailRequest$Type extends MessageType<MangaDetailRequest> {
    constructor() {
        super("MangaDetailRequest", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ID", kind: "scalar", jsonName: "ID", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MangaDetailRequest>): MangaDetailRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.name = "";
        message.iD = 0;
        if (value !== undefined)
            reflectionMergePartial<MangaDetailRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaDetailRequest): MangaDetailRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User */ 1:
                    message.user = reader.string();
                    break;
                case /* string Name = 2 [deprecated = true] */ 2:
                    message.name = reader.string();
                    break;
                case /* int32 ID */ 3:
                    message.iD = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaDetailRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string Name = 2 [deprecated = true]; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int32 ID = 3; */
        if (message.iD !== 0)
            writer.tag(3, WireType.Varint).int32(message.iD);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaDetailRequest
 */
export const MangaDetailRequest = new MangaDetailRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaDetailResponse$Type extends MessageType<MangaDetailResponse> {
    constructor() {
        super("MangaDetailResponse", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Favorite", kind: "scalar", jsonName: "Favorite", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "PageCount", kind: "scalar", jsonName: "PageCount", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "CurrentPage", kind: "scalar", jsonName: "CurrentPage", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "Tags", kind: "message", jsonName: "Tags", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MangaDetailResponseTagItem }
        ]);
    }
    create(value?: PartialMessage<MangaDetailResponse>): MangaDetailResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.favorite = false;
        message.pageCount = 0;
        message.currentPage = 0;
        message.tags = [];
        if (value !== undefined)
            reflectionMergePartial<MangaDetailResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaDetailResponse): MangaDetailResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name */ 1:
                    message.name = reader.string();
                    break;
                case /* bool Favorite */ 2:
                    message.favorite = reader.bool();
                    break;
                case /* int32 PageCount */ 3:
                    message.pageCount = reader.int32();
                    break;
                case /* int32 CurrentPage */ 4:
                    message.currentPage = reader.int32();
                    break;
                case /* repeated MangaDetailResponseTagItem Tags */ 5:
                    message.tags.push(MangaDetailResponseTagItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaDetailResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* bool Favorite = 2; */
        if (message.favorite !== false)
            writer.tag(2, WireType.Varint).bool(message.favorite);
        /* int32 PageCount = 3; */
        if (message.pageCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.pageCount);
        /* int32 CurrentPage = 4; */
        if (message.currentPage !== 0)
            writer.tag(4, WireType.Varint).int32(message.currentPage);
        /* repeated MangaDetailResponseTagItem Tags = 5; */
        for (let i = 0; i < message.tags.length; i++)
            MangaDetailResponseTagItem.internalBinaryWrite(message.tags[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaDetailResponse
 */
export const MangaDetailResponse = new MangaDetailResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaDetailResponseTagItem$Type extends MessageType<MangaDetailResponseTagItem> {
    constructor() {
        super("MangaDetailResponseTagItem", [
            { no: 1, name: "ID", kind: "scalar", jsonName: "ID", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "IsFavorite", kind: "scalar", jsonName: "IsFavorite", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "IsHidden", kind: "scalar", jsonName: "IsHidden", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MangaDetailResponseTagItem>): MangaDetailResponseTagItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iD = 0;
        message.name = "";
        message.isFavorite = false;
        message.isHidden = false;
        if (value !== undefined)
            reflectionMergePartial<MangaDetailResponseTagItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaDetailResponseTagItem): MangaDetailResponseTagItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 ID */ 1:
                    message.iD = reader.int32();
                    break;
                case /* string Name */ 2:
                    message.name = reader.string();
                    break;
                case /* bool IsFavorite */ 3:
                    message.isFavorite = reader.bool();
                    break;
                case /* bool IsHidden */ 4:
                    message.isHidden = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaDetailResponseTagItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 ID = 1; */
        if (message.iD !== 0)
            writer.tag(1, WireType.Varint).int32(message.iD);
        /* string Name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bool IsFavorite = 3; */
        if (message.isFavorite !== false)
            writer.tag(3, WireType.Varint).bool(message.isFavorite);
        /* bool IsHidden = 4; */
        if (message.isHidden !== false)
            writer.tag(4, WireType.Varint).bool(message.isHidden);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaDetailResponseTagItem
 */
export const MangaDetailResponseTagItem = new MangaDetailResponseTagItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaSetFavoriteRequest$Type extends MessageType<MangaSetFavoriteRequest> {
    constructor() {
        super("MangaSetFavoriteRequest", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Favorite", kind: "scalar", jsonName: "Favorite", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "ID", kind: "scalar", jsonName: "ID", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MangaSetFavoriteRequest>): MangaSetFavoriteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.name = "";
        message.favorite = false;
        message.iD = 0;
        if (value !== undefined)
            reflectionMergePartial<MangaSetFavoriteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaSetFavoriteRequest): MangaSetFavoriteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User */ 1:
                    message.user = reader.string();
                    break;
                case /* string Name = 2 [deprecated = true] */ 2:
                    message.name = reader.string();
                    break;
                case /* bool Favorite */ 3:
                    message.favorite = reader.bool();
                    break;
                case /* int32 ID */ 4:
                    message.iD = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaSetFavoriteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string Name = 2 [deprecated = true]; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bool Favorite = 3; */
        if (message.favorite !== false)
            writer.tag(3, WireType.Varint).bool(message.favorite);
        /* int32 ID = 4; */
        if (message.iD !== 0)
            writer.tag(4, WireType.Varint).int32(message.iD);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaSetFavoriteRequest
 */
export const MangaSetFavoriteRequest = new MangaSetFavoriteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaSetFavoriteResponse$Type extends MessageType<MangaSetFavoriteResponse> {
    constructor() {
        super("MangaSetFavoriteResponse", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Favorite", kind: "scalar", jsonName: "Favorite", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MangaSetFavoriteResponse>): MangaSetFavoriteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.favorite = false;
        if (value !== undefined)
            reflectionMergePartial<MangaSetFavoriteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaSetFavoriteResponse): MangaSetFavoriteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name */ 1:
                    message.name = reader.string();
                    break;
                case /* bool Favorite */ 2:
                    message.favorite = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaSetFavoriteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* bool Favorite = 2; */
        if (message.favorite !== false)
            writer.tag(2, WireType.Varint).bool(message.favorite);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaSetFavoriteResponse
 */
export const MangaSetFavoriteResponse = new MangaSetFavoriteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaSetProgressRequest$Type extends MessageType<MangaSetProgressRequest> {
    constructor() {
        super("MangaSetProgressRequest", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Page", kind: "scalar", jsonName: "Page", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "ID", kind: "scalar", jsonName: "ID", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MangaSetProgressRequest>): MangaSetProgressRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.name = "";
        message.page = 0;
        message.iD = 0;
        if (value !== undefined)
            reflectionMergePartial<MangaSetProgressRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaSetProgressRequest): MangaSetProgressRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User */ 1:
                    message.user = reader.string();
                    break;
                case /* string Name = 2 [deprecated = true] */ 2:
                    message.name = reader.string();
                    break;
                case /* int32 Page */ 3:
                    message.page = reader.int32();
                    break;
                case /* int32 ID */ 4:
                    message.iD = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaSetProgressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string Name = 2 [deprecated = true]; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int32 Page = 3; */
        if (message.page !== 0)
            writer.tag(3, WireType.Varint).int32(message.page);
        /* int32 ID = 4; */
        if (message.iD !== 0)
            writer.tag(4, WireType.Varint).int32(message.iD);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaSetProgressRequest
 */
export const MangaSetProgressRequest = new MangaSetProgressRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaSetProgressResponse$Type extends MessageType<MangaSetProgressResponse> {
    constructor() {
        super("MangaSetProgressResponse", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Page", kind: "scalar", jsonName: "Page", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "Succeed", kind: "scalar", jsonName: "Succeed", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MangaSetProgressResponse>): MangaSetProgressResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.name = "";
        message.page = 0;
        message.succeed = false;
        if (value !== undefined)
            reflectionMergePartial<MangaSetProgressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaSetProgressResponse): MangaSetProgressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User */ 1:
                    message.user = reader.string();
                    break;
                case /* string Name */ 2:
                    message.name = reader.string();
                    break;
                case /* int32 Page */ 3:
                    message.page = reader.int32();
                    break;
                case /* bool Succeed */ 4:
                    message.succeed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaSetProgressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string Name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int32 Page = 3; */
        if (message.page !== 0)
            writer.tag(3, WireType.Varint).int32(message.page);
        /* bool Succeed = 4; */
        if (message.succeed !== false)
            writer.tag(4, WireType.Varint).bool(message.succeed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaSetProgressResponse
 */
export const MangaSetProgressResponse = new MangaSetProgressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaUpdateCoverRequest$Type extends MessageType<MangaUpdateCoverRequest> {
    constructor() {
        super("MangaUpdateCoverRequest", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Index", kind: "scalar", jsonName: "Index", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "X", kind: "scalar", jsonName: "X", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "Y", kind: "scalar", jsonName: "Y", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "Width", kind: "scalar", jsonName: "Width", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "Height", kind: "scalar", jsonName: "Height", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "ID", kind: "scalar", jsonName: "ID", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MangaUpdateCoverRequest>): MangaUpdateCoverRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.index = 0;
        message.x = 0;
        message.y = 0;
        message.width = 0;
        message.height = 0;
        message.iD = 0;
        if (value !== undefined)
            reflectionMergePartial<MangaUpdateCoverRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaUpdateCoverRequest): MangaUpdateCoverRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 Index */ 2:
                    message.index = reader.int32();
                    break;
                case /* int32 X */ 3:
                    message.x = reader.int32();
                    break;
                case /* int32 Y */ 4:
                    message.y = reader.int32();
                    break;
                case /* int32 Width */ 5:
                    message.width = reader.int32();
                    break;
                case /* int32 Height */ 6:
                    message.height = reader.int32();
                    break;
                case /* int32 ID = 7 [deprecated = true] */ 7:
                    message.iD = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaUpdateCoverRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 Index = 2; */
        if (message.index !== 0)
            writer.tag(2, WireType.Varint).int32(message.index);
        /* int32 X = 3; */
        if (message.x !== 0)
            writer.tag(3, WireType.Varint).int32(message.x);
        /* int32 Y = 4; */
        if (message.y !== 0)
            writer.tag(4, WireType.Varint).int32(message.y);
        /* int32 Width = 5; */
        if (message.width !== 0)
            writer.tag(5, WireType.Varint).int32(message.width);
        /* int32 Height = 6; */
        if (message.height !== 0)
            writer.tag(6, WireType.Varint).int32(message.height);
        /* int32 ID = 7 [deprecated = true]; */
        if (message.iD !== 0)
            writer.tag(7, WireType.Varint).int32(message.iD);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaUpdateCoverRequest
 */
export const MangaUpdateCoverRequest = new MangaUpdateCoverRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaUpdateCoverResponse$Type extends MessageType<MangaUpdateCoverResponse> {
    constructor() {
        super("MangaUpdateCoverResponse", [
            { no: 1, name: "Success", kind: "scalar", jsonName: "Success", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MangaUpdateCoverResponse>): MangaUpdateCoverResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        if (value !== undefined)
            reflectionMergePartial<MangaUpdateCoverResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaUpdateCoverResponse): MangaUpdateCoverResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool Success */ 1:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaUpdateCoverResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool Success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaUpdateCoverResponse
 */
export const MangaUpdateCoverResponse = new MangaUpdateCoverResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaPageImageRequest$Type extends MessageType<MangaPageImageRequest> {
    constructor() {
        super("MangaPageImageRequest", [
            { no: 1, name: "User", kind: "scalar", jsonName: "User", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Index", kind: "scalar", jsonName: "Index", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "Width", kind: "scalar", jsonName: "Width", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "Height", kind: "scalar", jsonName: "Height", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "ID", kind: "scalar", jsonName: "ID", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MangaPageImageRequest>): MangaPageImageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.user = "";
        message.name = "";
        message.index = 0;
        message.width = 0;
        message.height = 0;
        message.iD = 0;
        if (value !== undefined)
            reflectionMergePartial<MangaPageImageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaPageImageRequest): MangaPageImageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string User */ 1:
                    message.user = reader.string();
                    break;
                case /* string Name = 2 [deprecated = true] */ 2:
                    message.name = reader.string();
                    break;
                case /* int32 Index */ 3:
                    message.index = reader.int32();
                    break;
                case /* int32 Width */ 4:
                    message.width = reader.int32();
                    break;
                case /* int32 Height */ 5:
                    message.height = reader.int32();
                    break;
                case /* int32 ID */ 6:
                    message.iD = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaPageImageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string User = 1; */
        if (message.user !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.user);
        /* string Name = 2 [deprecated = true]; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* int32 Index = 3; */
        if (message.index !== 0)
            writer.tag(3, WireType.Varint).int32(message.index);
        /* int32 Width = 4; */
        if (message.width !== 0)
            writer.tag(4, WireType.Varint).int32(message.width);
        /* int32 Height = 5; */
        if (message.height !== 0)
            writer.tag(5, WireType.Varint).int32(message.height);
        /* int32 ID = 6; */
        if (message.iD !== 0)
            writer.tag(6, WireType.Varint).int32(message.iD);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaPageImageRequest
 */
export const MangaPageImageRequest = new MangaPageImageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaPageImageResponse$Type extends MessageType<MangaPageImageResponse> {
    constructor() {
        super("MangaPageImageResponse", [
            { no: 1, name: "ContentType", kind: "scalar", jsonName: "ContentType", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Data", kind: "scalar", jsonName: "Data", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<MangaPageImageResponse>): MangaPageImageResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contentType = "";
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<MangaPageImageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaPageImageResponse): MangaPageImageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ContentType */ 1:
                    message.contentType = reader.string();
                    break;
                case /* bytes Data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaPageImageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ContentType = 1; */
        if (message.contentType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contentType);
        /* bytes Data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaPageImageResponse
 */
export const MangaPageImageResponse = new MangaPageImageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaPageImageStreamResponse$Type extends MessageType<MangaPageImageStreamResponse> {
    constructor() {
        super("MangaPageImageStreamResponse", [
            { no: 1, name: "Filename", kind: "scalar", jsonName: "Filename", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ContentType", kind: "scalar", jsonName: "ContentType", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Data", kind: "scalar", jsonName: "Data", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "Size", kind: "scalar", jsonName: "Size", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MangaPageImageStreamResponse>): MangaPageImageStreamResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filename = "";
        message.contentType = "";
        message.data = new Uint8Array(0);
        message.size = 0;
        if (value !== undefined)
            reflectionMergePartial<MangaPageImageStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaPageImageStreamResponse): MangaPageImageStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Filename */ 1:
                    message.filename = reader.string();
                    break;
                case /* string ContentType */ 2:
                    message.contentType = reader.string();
                    break;
                case /* bytes Data */ 3:
                    message.data = reader.bytes();
                    break;
                case /* int32 Size */ 4:
                    message.size = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaPageImageStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Filename = 1; */
        if (message.filename !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.filename);
        /* string ContentType = 2; */
        if (message.contentType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contentType);
        /* bytes Data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        /* int32 Size = 4; */
        if (message.size !== 0)
            writer.tag(4, WireType.Varint).int32(message.size);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaPageImageStreamResponse
 */
export const MangaPageImageStreamResponse = new MangaPageImageStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaRepairRequest$Type extends MessageType<MangaRepairRequest> {
    constructor() {
        super("MangaRepairRequest", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "ID", kind: "scalar", jsonName: "ID", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MangaRepairRequest>): MangaRepairRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.iD = 0;
        if (value !== undefined)
            reflectionMergePartial<MangaRepairRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaRepairRequest): MangaRepairRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [deprecated = true] */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 ID */ 3:
                    message.iD = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaRepairRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [deprecated = true]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 ID = 3; */
        if (message.iD !== 0)
            writer.tag(3, WireType.Varint).int32(message.iD);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaRepairRequest
 */
export const MangaRepairRequest = new MangaRepairRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaRepairResponse$Type extends MessageType<MangaRepairResponse> {
    constructor() {
        super("MangaRepairResponse", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "IsSuccess", kind: "scalar", jsonName: "IsSuccess", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MangaRepairResponse>): MangaRepairResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.isSuccess = false;
        if (value !== undefined)
            reflectionMergePartial<MangaRepairResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaRepairResponse): MangaRepairResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name */ 1:
                    message.name = reader.string();
                    break;
                case /* bool IsSuccess */ 2:
                    message.isSuccess = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaRepairResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* bool IsSuccess = 2; */
        if (message.isSuccess !== false)
            writer.tag(2, WireType.Varint).bool(message.isSuccess);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaRepairResponse
 */
export const MangaRepairResponse = new MangaRepairResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaDownloadRequest$Type extends MessageType<MangaDownloadRequest> {
    constructor() {
        super("MangaDownloadRequest", [
            { no: 1, name: "Name", kind: "scalar", jsonName: "Name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ID", kind: "scalar", jsonName: "ID", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MangaDownloadRequest>): MangaDownloadRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.iD = 0;
        if (value !== undefined)
            reflectionMergePartial<MangaDownloadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaDownloadRequest): MangaDownloadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Name = 1 [deprecated = true] */ 1:
                    message.name = reader.string();
                    break;
                case /* int32 ID */ 2:
                    message.iD = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaDownloadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Name = 1 [deprecated = true]; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* int32 ID = 2; */
        if (message.iD !== 0)
            writer.tag(2, WireType.Varint).int32(message.iD);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaDownloadRequest
 */
export const MangaDownloadRequest = new MangaDownloadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MangaDownloadResponse$Type extends MessageType<MangaDownloadResponse> {
    constructor() {
        super("MangaDownloadResponse", [
            { no: 1, name: "Filename", kind: "scalar", jsonName: "Filename", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ContentType", kind: "scalar", jsonName: "ContentType", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "Data", kind: "scalar", jsonName: "Data", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "Size", kind: "scalar", jsonName: "Size", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MangaDownloadResponse>): MangaDownloadResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filename = "";
        message.contentType = "";
        message.data = new Uint8Array(0);
        message.size = 0;
        if (value !== undefined)
            reflectionMergePartial<MangaDownloadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MangaDownloadResponse): MangaDownloadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Filename */ 1:
                    message.filename = reader.string();
                    break;
                case /* string ContentType */ 2:
                    message.contentType = reader.string();
                    break;
                case /* bytes Data */ 3:
                    message.data = reader.bytes();
                    break;
                case /* int32 Size */ 4:
                    message.size = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MangaDownloadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Filename = 1; */
        if (message.filename !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.filename);
        /* string ContentType = 2; */
        if (message.contentType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contentType);
        /* bytes Data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        /* int32 Size = 4; */
        if (message.size !== 0)
            writer.tag(4, WireType.Varint).int32(message.size);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MangaDownloadResponse
 */
export const MangaDownloadResponse = new MangaDownloadResponse$Type();
/**
 * @generated ServiceType for protobuf service Manga
 */
export const Manga = new ServiceType("Manga", [
    { name: "List", options: {}, I: MangaListRequest, O: MangaListResponse },
    { name: "Detail", options: {}, I: MangaDetailRequest, O: MangaDetailResponse },
    { name: "Thumbnail", options: {}, I: MangaThumbnailRequest, O: MangaThumbnailResponse },
    { name: "SetFavorite", options: {}, I: MangaSetFavoriteRequest, O: MangaSetFavoriteResponse },
    { name: "SetProgress", options: {}, I: MangaSetProgressRequest, O: MangaSetProgressResponse },
    { name: "UpdateCover", options: {}, I: MangaUpdateCoverRequest, O: MangaUpdateCoverResponse },
    { name: "PageImage", options: {}, I: MangaPageImageRequest, O: MangaPageImageResponse },
    { name: "PageImageStream", serverStreaming: true, options: {}, I: MangaPageImageRequest, O: MangaPageImageStreamResponse },
    { name: "Repair", options: {}, I: MangaRepairRequest, O: MangaRepairResponse },
    { name: "Download", serverStreaming: true, options: {}, I: MangaDownloadRequest, O: MangaDownloadResponse }
]);
